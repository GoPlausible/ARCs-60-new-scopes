---
arc: 13
title: Web Extension Wallet Interface
description: A common interface for multiple web extension wallets to interact with dapps.
author: Kieran O'Neill (@kieranroneill)
discussions-to: <URL>
status: Draft
type: Standards Track
category: Interface
created: 2023-12-18
requires (*optional): <ARC number(s)>
---

# Web Extension Wallet Interface

## Abstract

Building off of the previous ARCs relating to; wallet transaction signing ([ARC-0005](./arc-0005.md#specification)), wallet address discovery ([ARC-0006](./arc-0006.md#specification)), wallet transaction network posting ([ARC-0007](./arc-0007.md#specification)) and wallet transaction signing & posting ([ARC-0008](./arc-0008.md#specification)), this proposal aims to extend and comprehensively outline a common interface between multiple web extension wallets and dapps by utilizing the pub/sub semantics of the [BroadcastChannel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API).

## Motivation

Two common patterns have emerged amongst web extension wallets:

| Description                                                                                                                                                                                                                                                                                                                                                                                                                          | Benefits                                                                                                                                                                                                                                                                                                                    | Drawbacks                                                                                                                                                                                                                        |
|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| The global `window.algorand` object is overwritten by an injected script from a web extension's content script. This overwritten object will provide features that allows the dapp to interact with the wallet which may or may not conform to previous ARCs ([ARC-0005](./arc-0005.md#specification), [ARC-0006](./arc-0005.md#specification), [ARC-0007](./arc-0007.md#specification) or [ARC-0008](./arc-0008.md#specification)). | - Dapps will not have to install any external SDKs<br/>- Dapps do not need to know which wallet the user is using (if the injected wallet conforms to [ARC-0005](./arc-0005.md#specification), [ARC-0006](./arc-0005.md#specification), [ARC-0007](./arc-0007.md#specification) or [ARC-0008](./arc-0008.md#specification)) | - In the instance of multiple web extension wallets, another wallet extension may overwrite this object.<br/>- Once overwritten, the `window.algorand` object will only service the last web extension wallet that overwrote it. |
| A wallet provides a separate SDK that is installed by a dapp to interact with the wallet.                                                                                                                                                                                                                                                                                                                                            | - Allows wallets full control over how dapps interact with wallets, ie. provide a bespoke UX.                                                                                                                                                                                                                               | - Dapps need to install each SDK separately, thereby increasing the amount of development time, and complexity, needed to implement each wallet separately.                                                                      |

While both patterns have merits, they can stumble when it comes to allowing dapps to be un-opinionated about what wallet the user intends to use. 

This proposal intends to outline a common interface that, at it's core, will subscribe to some fundamental goals:

1. Creating a common interface between dapps and wallets.
2. Allowing wallets to work in unison.
3. Full authority of wallet choice is in the hands the user.

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119</a>.

> Comments like this are non-normative.

### Overview

The essence of the web extension wallet interface will lie in the simple messaging bus mechanism of the [BroadcastChannel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API).

A dapp will broadcast a message and any web extension wallet's [content scripts](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts) will listen for these broadcasted messages and act upon them, responding with another broadcast message that references the original request broadcast.

The dapp will, itself, listen to broadcasted responses from any web extension wallets.

![Simple BroadcastChannel API using web extensions](../assets/arc-0013/simple_message_bus.png)

### Definitions

This section is non-normative.

* Dapp
  - The end-user application that interacts with the web extension wallet; the provider.
* Provider
  - A web extension wallet, that manages private keys and performs signing operations.


### Setup

1. (**REQUIRED**) Both the dapp and the provider must create/join a broadcast channel with a common channel name:

```typescript
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');
```

> ⚠️ **NOTE:** As providers are web extensions, they **MUST** create/join the `BroadcastChannel` in a content script. This allows the content scripts to subscribe to the channel and listen and broadcast messages.

### Message Reference Naming

In order for each message to be identifiable, each message **MUST** contain a `reference` property. Furthermore, this `reference` property **MUST** conform to the naming convention:

```
[standard]:[event_name]:[type]
```
where:
* `standard`:
    - **MUST** be `arc0013`
* `event_name`:
    - **MUST** be in snake case
* `type`:
    - **MUST** be one of `request` or `response`

This convention ensures that each message can be identified and handled.

### Supported Message Methods

#### Get Providers

Usually called by a dapp to get responses of any available providers. If the `params.providerId` property is supplied, only the provider with the matching ID **SHOULD** respond.

For example, see [here](#get-providers-example).

**Request Payload**

```json
{
  "title": "Get Providers Request Payload",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "description": "A globally unique identifier for the message"
    },
    "params": {
      "type": "object",
      "properties": {
        "providerId": {
          "type": "string",
          "description": "A unique identifier for the provider"
        }
      }
    },
    "reference": {
      "type": "string",
      "description": "Identifies the purpose of the message"
    }
  },
  "required": ["id", "reference"]
}
```
where:
* `id`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `params`:
  - **OPTIONAL** if omitted, all providers **MAY** respond
* `params.providerId`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `reference`:
  - **MUST** be `arc0013:get_providers:request`

**Response Payload**

```json
{
  "title": "Get Providers Response Payload",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "description": "A globally unique identifier for the message"
    },
    "params": {
      "type": "object",
      "properties": {
        "host": {
          "type": "string",
          "description": "A domain name of the provider"
        },
        "icon": {
          "type": "string",
          "description": "A URI pointing to an image"
        },
        "name": {
          "type": "string",
          "description": "A human-readable canonical name of the provider"
        },
        "networks": {
          "type": "array",
          "description": "A list of networks available for the provider",
          "items": {
            "type": "object",
            "properties": {
              "genesisHash": {
                "type": "string",
                "description": "The unique identifier for the network that is the hash of the genesis block"
              },
              "genesisId": {
                "type": "string",
                "description": "A human-readable identifier for the network"
              },
              "methods": {
                "type": "array",
                "description": "A list of methods available on the provider for the chain",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": ["id", "methods"]
          }
        },
        "providerId": {
          "type": "string",
          "description": "A globally unique identifier for the provider"
        }
      },
      "required": [
        "name",
        "networks",
        "providerId"
      ]
    },
    "reference": {
      "type": "string",
      "description": "Identifies the purpose of the message"
    },
    "requestId": {
      "type": "string",
      "description": "The ID of the request message"
    }
  },
  "required": [
    "id",
    "params",
    "reference",
    "requestId"
  ]
}
```
where:
* `id`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `params.networks`:
  - **MAY** be empty
* `params.networks.genesisHash`:
  - **MUST** be base64 encoded hash of the genesis block of the network
* `params.networks.methods`:
  - **SHOULD** be one or all of `enable`, `postTxns`, `signBytes`, `signTxns`, `signAndPostTxns`
  - **MAY** be empty
* `params.host`:
  - **RECOMMENDED** a URL that points to a live website
* `params.icon`:
  - **RECOMMENDED** be a URI that conforms to [RFC-2397](https://www.rfc-editor.org/rfc/rfc2397)
  - **SHOULD** be a URI that points to a square image with a 96x96px minimum resolution
  - **RECOMMENDED** image format to be either lossless or vector based such as PNG, WebP or SVG
* `params.providerId`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
  - **MUST** uniquely identify the provider
* `params.name`:
  - **SHOULD** be human-readable to allow for display to a user
* `reference`:
  - **MUST** be `arc0013:get_providers:response`
* `requestId`:
  - **MUST** be the ID of the origin request message

> ⚠️ **NOTE:** If the `requestId` is missing, or does not match the ID of the origin request message, the response **SHOULD** be ignored.

#### Enable

Asks providers to enable the requesting dapp on the provider. The response will **MUST** return a user-curated list of available addresses.

Providers **SHOULD** create a "session" for the dapp, what this should look like is the prerogative of the provider and is beyond the scope of this proposal.

For example, see [here](#enable-example).

**Request Payload**

```json
{
  "title": "Enable Request Payload",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "description": "A globally unique identifier for the message"
    },
    "params": {
      "type": "object",
      "properties": {
        "genesisHash": {
          "type": "string",
          "description": "The unique identifier for the network that is the hash of the genesis block"
        },
        "providerId": {
          "type": "string",
          "description": "A unique identifier for the provider"
        }
      }
    },
    "reference": {
      "type": "string",
      "description": "Identifies the purpose of the message"
    }
  },
  "required": ["id", "reference"]
}
```
where:
* `id`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `params`:
  - **OPTIONAL** if omitted, all providers **MAY** respond
* `params.genesisHash`:
  - **MUST** be base64 encoded hash of the genesis block of the network
  - **OPTIONAL** if omitted, the provider **SHOULD** assume a "default" chain
* `params.providerId`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
  - **OPTIONAL** if omitted, all providers **MAY** respond
* `reference`:
  - **MUST** be `arc0013:enable:request`

**Response Payload**

```json
{
  "title": "Enable Response Payload",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "description": "A globally unique identifier for the message"
    },
    "params": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "description": "A list of accounts available for the provider",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string",
                "description": "The address of the account"
              },
              "name": {
                "type": "string",
                "description": "A human-readable name for this account"
              }
            },
            "required": ["address"]
          }
        },
        "genesisHash": {
          "type": "string",
          "description": "The unique identifier for the network that is the hash of the genesis block"
        },
        "genesisId": {
          "type": "string",
          "description": "A human-readable identifier for the network"
        },
        "providerId": {
          "type": "string",
          "description": "A unique identifier for the provider"
        },
        "sessionId": {
          "type": "string",
          "description": "A globally unique identifier for the session as defined by the provider"
        }
      },
      "required": [
        "accounts",
        "genesisHash",
        "genesisId",
        "providerId"
      ]
    },
    "reference": {
      "type": "string",
      "description": "Identifies the purpose of the message"
    },
    "requestId": {
      "type": "string",
      "description": "The ID of the request message"
    }
  },
  "required": [
    "id",
    "params",
    "reference",
    "requestId"
  ]
}
```
where:
* `id`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `params.accounts`:
  - **MAY** be empty
* `params.accounts.address`:
  - **MUST** be a base32 encoded public key with a 4 byte checksum appended as defined in [keys and addresses](https://developer.algorand.org/docs/get-details/accounts/#keys-and-addresses)
* `params.genesisHash`:
  - **MUST** be base64 encoded hash of the genesis block for the network
* `params.providerId`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
  - **MUST** uniquely identify the provider
* `params.sessionId`:
  - **RECOMMENDED** to be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `reference`:
  - **MUST** be `arc0013:enable:response`
* `requestId`:
  - **MUST** be the ID of the origin request message










## Rationale
The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages.

## Backwards Compatibility
All ARCs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The ARC must explain how the author proposes to deal with these incompatibilities. ARC submissions without a sufficient backwards compatibility treatise may be rejected outright.

## Test Cases
Test cases for an implementation are mandatory for ARCs that are affecting consensus changes.  If the test suite is too large to reasonably be included inline, then consider adding it as one or more files in `../assets/arc-####/`.

## Reference Implementation

### Get Providers Example

```typescript
// dapp - main.ts
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');

channel.onmessage = (message) => {
  switch (message.data?.reference) {
    case 'arc0013:get_providers:response':
      // handle response from provider
      console.log(message.data.params.name); // "Awesome Wallet"
      break;
    default:
      break;
  }
};

channel.postMessage({
  id: '5d5186fc-2091-4e88-8ef9-05a5d4da24ed',
  reference: 'arc0013:get_providers:request',
});
```
```typescript
// provider - content-script.ts
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');

channel.onmessage = (message) => {
  switch (message.data?.reference) {
    case 'arc0013:get_providers:request':
      channel.postMessage({
        id: '6695f990-e3d7-41c4-bb26-64ab8da0653b',
        params: {
          host: 'https://awesome-wallet.com',
          icon: 'data:image/png;base64,iVBORw0KGgoAAAANSUh...',
          name: 'Awesome Wallet',
          networks: [
            {
              genesisHash: 'wGHE2Pwdvd7S12BL5FaOP20EGYesN73ktiC1qzkkit8=',
              genesisId: 'mainnet-v1.0',
              methods: ['enable', 'postTxns', 'signBytes', 'signTxns', 'signAndPostTxns'],
            },
            {
              genesisHash: 'SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI=',
              genesisId: 'testnet-v1.0',
              methods: ['enable', 'postTxns', 'signBytes', 'signTxns', 'signAndPostTxns'],
            },
          ],
          providerId: '85533948-4d0b-4727-904e-dd35305d49aa',
        },
        reference: 'arc0013:get_providers:response',
        requestId: message.data.id, // use the request id
      });
      break;
    default:
      break;
  }
};
```

### Enable Example

```typescript
// dapp - main.ts
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');

channel.onmessage = (message) => {
  switch (message.data?.reference) {
    case 'arc0013:enable:response':
      // handle response from provider
      console.log(message.data?.params.accounts[0].address); // "ARCI3GVTJO27GGSWHZR2S3E7UY46KXFLBC6CLEMF7GY3UYF7YWGWC6NPTA"
      break;
    default:
      break;
  }
};

channel.postMessage({
  id: '7fdbea43-5b7d-40af-ae6c-feff84e775fb',
  params: {
    genesisHash: 'SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI=',
    providerId: '85533948-4d0b-4727-904e-dd35305d49aa',
  },
  reference: 'arc0013:enable:request',
});
```
```typescript
// provider - content-script.ts
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');

channel.onmessage = (message) => {
  switch (message.data?.reference) {
    case 'arc0013:enable:request':
      channel.postMessage({
        id: '6695f990-e3d7-41c4-bb26-64ab8da0653b',
        params: {
          accounts: [{
            address: 'ARCI3GVTJO27GGSWHZR2S3E7UY46KXFLBC6CLEMF7GY3UYF7YWGWC6NPTA',
            name: 'Main Account',
          }],
          genesisHash: 'SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI=',
          genesisId: 'testnet-v1.0',
          providerId: '85533948-4d0b-4727-904e-dd35305d49aa',
          sessionId: '6eb74cf1-93e8-400c-94b5-4928807a3ab1',
        },
        reference: 'arc0013:enable:response',
        requestId: message.data.id, // use the request id
      });
      break;
    default:
      break;
  }
};
```









An optional section that contains a reference/example implementation that people can use to assist in understanding or implementing this specification.  If the implementation is too large to reasonably be included inline, then consider adding it as one or more files in `../assets/arc-####/`.





## Security Considerations
All ARCs must contain a section that discusses the security implications/considerations relevant to the proposed change. Include information that might be important for security discussions, surfaces risks and can be used throughout the life cycle of the proposal. E.g. include security-relevant design decisions, concerns, important discussions, implementation-specific guidance and pitfalls, an outline of threats and risks and how they are being addressed. ARC submissions missing the "Security Considerations" section will be rejected. An ARC cannot proceed to status "Final" without a Security Considerations discussion deemed sufficient by the reviewers.

## Copyright
Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.
