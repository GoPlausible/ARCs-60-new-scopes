---
arc: 13
title: Web Extension Wallet Interface
description: A common interface for multiple web extension wallets to interact with dapps.
author: Kieran O'Neill (@kieranroneill)
status: Draft
type: Standards Track
category: Interface
created: 2023-12-18
---

# Web Extension Wallet Interface

## Abstract

Building off of the previous ARCs relating to; wallet transaction signing ([ARC-0005](./arc-0005.md#specification)), wallet address discovery ([ARC-0006](./arc-0006.md#specification)), wallet transaction network posting ([ARC-0007](./arc-0007.md#specification)) and wallet transaction signing & posting ([ARC-0008](./arc-0008.md#specification)), this proposal aims to extend and comprehensively outline a common interface between multiple web extension wallets and dapps by utilizing the pub/sub semantics of the [BroadcastChannel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API).

## Motivation

Two common patterns have emerged amongst web extension wallets:

| Description                                                                                                                                                                                                                                                                                                                                                                                                                          | Benefits                                                                                                                                                                                                                                                                                                                    | Drawbacks                                                                                                                                                                                                                        |
|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| The global `window.algorand` object is overwritten by an injected script from a web extension's content script. This overwritten object will provide features that allows the dapp to interact with the wallet which may or may not conform to previous ARCs ([ARC-0005](./arc-0005.md#specification), [ARC-0006](./arc-0005.md#specification), [ARC-0007](./arc-0007.md#specification) or [ARC-0008](./arc-0008.md#specification)). | - Dapps will not have to install any external SDKs<br/>- Dapps do not need to know which wallet the user is using (if the injected wallet conforms to [ARC-0005](./arc-0005.md#specification), [ARC-0006](./arc-0005.md#specification), [ARC-0007](./arc-0007.md#specification) or [ARC-0008](./arc-0008.md#specification)) | - In the instance of multiple web extension wallets, another wallet extension may overwrite this object.<br/>- Once overwritten, the `window.algorand` object will only service the last web extension wallet that overwrote it. |
| A wallet provides a separate SDK that is installed by a dapp to interact with the wallet.                                                                                                                                                                                                                                                                                                                                            | - Allows wallets full control over how dapps interact with wallets, ie. provide a bespoke UX.                                                                                                                                                                                                                               | - Dapps need to install each SDK separately, thereby increasing the amount of development time, and complexity, needed to implement each wallet separately.                                                                      |

While both patterns have merits, they can stumble when it comes to allowing dapps to be un-opinionated about what wallet the user intends to use. 

This proposal intends to outline a common interface that, at it's core, will subscribe to some fundamental goals:

1. Creating a common interface between dapps and wallets.
2. Allowing wallets to work in unison.
3. Full authority of wallet choice is in the hands the user.

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119</a>.

> Comments like this are non-normative.

### Definitions

This section is non-normative.

* Dapp
  - The end-user application that interacts with the web extension wallet; the provider.
* Provider
  - A web extension wallet, that manages private keys and performs signing operations.

### Overview

The essence of the provider interface will lie in using the simple messaging bus mechanism of the [BroadcastChannel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API).

A dapp will broadcast a message and the provider's [content scripts](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts) will listen for these broadcasted messages and act upon them, responding with another broadcast message that references the original request broadcast.

The dapp will, itself, listen to broadcasted responses from any providers. Below is a simple diagram for the flow of data for an enable request:

![Simple BroadcastChannel API using web extensions](../assets/arc-0013/simple_message_bus.png)

### Setup

Both the dapp and the provider **MUST** create/join a broadcast channel with a common channel name:

```typescript
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');
```

> ⚠️ **NOTE:** As providers are web extensions, they **MUST** create/join the `BroadcastChannel` in a content script. As content scripts share the same origin as the dapp, they are able to subscribe to the same channel and listen/broadcast messages.

### Message Reference Naming

In order for each message to be identifiable, each message **MUST** contain a `reference` property. Furthermore, this `reference` property **MUST** conform to the following naming convention:

```
[standard]:[method]:[type]
```
where:
* `standard`:
    - **MUST** be `arc0013`
* `method`:
    - **MUST** be in snake case
    - **MUST** be the name of the method being undertaken
* `type`:
    - **MUST** be one of `request` or `response`

This convention ensures that each message can be identified and handled.

### Supported Methods

#### Get Providers

Sent by a dapp to get responses of any available providers. If the `params.providerId` property is supplied, only the provider with the matching ID **SHOULD** respond.

This method is usually called before other methods as it allows the dapp to get the identity of providers, the networks the provider supports and the methods the provider supports on each network.

For example, see [here](#get-providers-example).

**Request Payload**

```json
{
  "title": "Get Providers Request Payload",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "description": "A globally unique identifier for the message"
    },
    "params": {
      "type": "object",
      "properties": {
        "providerId": {
          "type": "string",
          "description": "A unique identifier for the provider"
        }
      }
    },
    "reference": {
      "type": "string",
      "description": "Identifies the purpose of the message"
    }
  },
  "required": ["id", "reference"]
}
```
where:
* `id`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `params`:
  - **OPTIONAL** if omitted, all providers **MAY** respond
* `params.providerId`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `reference`:
  - **MUST** be `arc0013:get_providers:request`

**Response Payload**

```json
{
  "title": "Get Providers Response Payload",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "description": "A globally unique identifier for the message"
    },
    "params": {
      "type": "object",
      "properties": {
        "host": {
          "type": "string",
          "description": "A domain name of the provider"
        },
        "icon": {
          "type": "string",
          "description": "A URI pointing to an image"
        },
        "name": {
          "type": "string",
          "description": "A human-readable canonical name of the provider"
        },
        "networks": {
          "type": "array",
          "description": "A list of networks available for the provider",
          "items": {
            "type": "object",
            "properties": {
              "genesisHash": {
                "type": "string",
                "description": "The unique identifier for the network that is the hash of the genesis block"
              },
              "genesisId": {
                "type": "string",
                "description": "A human-readable identifier for the network"
              },
              "methods": {
                "type": "array",
                "description": "A list of methods available on the provider for the chain",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": ["id", "methods"]
          }
        },
        "providerId": {
          "type": "string",
          "description": "A globally unique identifier for the provider"
        }
      },
      "required": [
        "name",
        "networks",
        "providerId"
      ]
    },
    "reference": {
      "type": "string",
      "description": "Identifies the purpose of the message"
    },
    "requestId": {
      "type": "string",
      "description": "The ID of the request message"
    }
  },
  "required": [
    "id",
    "params",
    "reference",
    "requestId"
  ]
}
```
where:
* `id`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `params.networks`:
  - **MAY** be empty
* `params.networks.genesisHash`:
  - **MUST** be a base64 encoded hash of the genesis block of the network
* `params.networks.methods`:
  - **SHOULD** be one or all of `enable`, `postTxns`, `signAndPostTxns`, `signBytes` or `signTxns`
  - **MAY** be empty
* `params.host`:
  - **RECOMMENDED** a URL that points to a live website
* `params.icon`:
  - **RECOMMENDED** be a URI that conforms to [RFC-2397](https://www.rfc-editor.org/rfc/rfc2397)
  - **SHOULD** be a URI that points to a square image with a 96x96px minimum resolution
  - **RECOMMENDED** image format to be either lossless or vector based such as PNG, WebP or SVG
* `params.providerId`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
  - **MUST** uniquely identify the provider
* `params.name`:
  - **SHOULD** be human-readable to allow for display to a user
* `reference`:
  - **MUST** be `arc0013:get_providers:response`
* `requestId`:
  - **MUST** be the ID of the origin request message

> ⚠️ **NOTE:** If the `requestId` is missing, or does not match the ID of the origin request message, the response **SHOULD** be ignored.

#### Enable

Asks providers to enable the requesting dapp. The response **MUST** return a user-curated list of available addresses.

Providers **SHOULD** create a "session" for the dapp, what this should look like is the prerogative of the provider and is beyond the scope of this proposal.

For example, see [here](#enable-example).

**Request Payload**

```json
{
  "title": "Enable Request Payload",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "description": "A globally unique identifier for the message"
    },
    "params": {
      "type": "object",
      "properties": {
        "genesisHash": {
          "type": "string",
          "description": "The unique identifier for the network that is the hash of the genesis block"
        },
        "providerId": {
          "type": "string",
          "description": "A unique identifier for the provider"
        }
      }
    },
    "reference": {
      "type": "string",
      "description": "Identifies the purpose of the message"
    }
  },
  "required": ["id", "reference"]
}
```
where:
* `id`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `params`:
  - **OPTIONAL** if omitted, all providers **MAY** respond
* `params.genesisHash`:
  - **MUST** be a base64 encoded hash of the genesis block of the network
  - **OPTIONAL** if omitted, the provider **SHOULD** assume a "default" network
* `params.providerId`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
  - **OPTIONAL** if omitted, all providers **MAY** respond
* `reference`:
  - **MUST** be `arc0013:enable:request`

**Response Payload**

```json
{
  "title": "Enable Response Payload",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "description": "A globally unique identifier for the message"
    },
    "params": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "description": "A list of accounts available for the provider",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string",
                "description": "The address of the account"
              },
              "name": {
                "type": "string",
                "description": "A human-readable name for this account"
              }
            },
            "required": ["address"]
          }
        },
        "genesisHash": {
          "type": "string",
          "description": "The unique identifier for the network that is the hash of the genesis block"
        },
        "genesisId": {
          "type": "string",
          "description": "A human-readable identifier for the network"
        },
        "providerId": {
          "type": "string",
          "description": "A unique identifier for the provider"
        },
        "sessionId": {
          "type": "string",
          "description": "A globally unique identifier for the session as defined by the provider"
        }
      },
      "required": [
        "accounts",
        "genesisHash",
        "genesisId",
        "providerId"
      ]
    },
    "reference": {
      "type": "string",
      "description": "Identifies the purpose of the message"
    },
    "requestId": {
      "type": "string",
      "description": "The ID of the request message"
    }
  },
  "required": [
    "id",
    "params",
    "reference",
    "requestId"
  ]
}
```
where:
* `id`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `params.accounts`:
  - **MAY** be empty
* `params.accounts.address`:
  - **MUST** be a base32 encoded public key with a 4 byte checksum appended as defined in [keys and addresses](https://developer.algorand.org/docs/get-details/accounts/#keys-and-addresses)
* `params.genesisHash`:
  - **MUST** be a base64 encoded hash of the genesis block of the network
* `params.providerId`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
  - **MUST** uniquely identify the provider
* `params.sessionId`:
  - **RECOMMENDED** to be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `reference`:
  - **MUST** be `arc0013:enable:response`
* `requestId`:
  - **MUST** be the ID of the origin request message

#### Sign Transactions

Sends a list of transactions to be signed by the provider(s).

For example, see [here](#sign-transactions-example).

**Request Payload**

```json
{
  "title": "Sign Transactions Request Payload",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "description": "A globally unique identifier for the message"
    },
    "params": {
      "type": "object",
      "properties": {
        "genesisHash": {
          "type": "string",
          "description": "The unique identifier for the network that is the hash of the genesis block"
        },
        "providerId": {
          "type": "string",
          "description": "A unique identifier for the provider"
        },
        "txns": {
          "type": "array",
          "description": "A list of transactions to be signed by the provider",
          "items": {
            "type": "object",
            "properties": {
              "authAddr": {
                "type": "string",
                "description": "The auth address if the sender has rekeyed"
              },
              "msig": {
                "type": "object",
                "description": "Extra metadata needed when sending multisig transactions",
                "properties": {
                  "addrs": {
                    "type": "array",
                    "description": "A list of Algorand addresses representing possible signers for the multisig",
                    "items": {
                      "type": "string"
                    }
                  },
                  "threshold": {
                    "type": "integer",
                    "description": "Multisig threshold value"
                  },
                  "version": {
                    "type": "integer",
                    "description": "Multisig version"
                  }
                }
              },
              "signers": {
                "type": "array",
                "description": "A list of addresses to sign with",
                "items": {
                  "type": "string"
                }
              },
              "stxn": {
                "type": "string",
                "description": "The base64 encoded signed transaction"
              },
              "txn": {
                "type": "string",
                "description": "The base64 encoded unsigned transaction"
              }
            },
            "required": ["txn"]
          }
        }
      },
      "required": [
        "txns"
      ]
    },
    "reference": {
      "type": "string",
      "description": "Identifies the purpose of the message"
    }
  },
  "required": [
    "id",
    "params",
    "reference"
  ]
}
```
where:
* `id`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `params.genesisHash`:
  - **MUST** be a base64 encoded hash of the genesis block of the network
  - **OPTIONAL** if omitted, the provider **SHOULD** assume a "default" network
* `params.providerId`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
  - **OPTIONAL** if omitted, all providers **MAY** respond
* `params.txns`:
  - **MUST** have each item conform to the semantic of a transaction in [ARC0001](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0001.md#semantic-of-wallettransaction)
  - **MAY** be empty
  - **MUST** have a maximum length of 16 as this is the maximum amount of grouped (atomic) transactions that are allowed by the Algorand protocol
* `reference`:
  - **MUST** be `arc0013:sign_txns:request`

**Response Payload**

```json
{
  "title": "Sign Transactions Response Payload",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "description": "A globally unique identifier for the message"
    },
    "params": {
      "type": "object",
      "properties": {
        "genesisHash": {
          "type": "string",
          "description": "The unique identifier for the network that is the hash of the genesis block"
        },
        "genesisId": {
          "type": "string",
          "description": "A human-readable identifier for the network"
        },
        "providerId": {
          "type": "string",
          "description": "A unique identifier for the provider"
        },
        "stxns": {
          "type": "array",
          "description": "A list of base64 encoded signed transactions that is ready to be posted to the network",
          "items": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "required": [
        "genesisHash",
        "providerId",
        "stxns"
      ]
    },
    "reference": {
      "type": "string",
      "description": "Identifies the purpose of the message"
    },
    "requestId": {
      "type": "string",
      "description": "The ID of the request message"
    }
  },
  "required": [
    "id",
    "params",
    "reference",
    "requestId"
  ]
}
```
where:
* `id`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
* `params.genesisHash`:
  - **MUST** be a base64 encoded hash of the genesis block of the network
* `params.providerId`:
  - **MUST** be a [UUIDv4](https://www.rfc-editor.org/rfc/rfc4122) compliant string
  - **MUST** uniquely identify the provider
* `params.stxns`:
  - **MAY** have an item that is a base64 encoding of a signed transaction
  - **MAY** have an item that is null if the transaction at the same index in the request's `txns` list was not signed by the provider
  - **MAY** be empty
* `reference`:
  - **MUST** be `arc0013:sign_txns:response`
* `requestId`:
  - **MUST** be the ID of the origin request message

### Sign Bytes


## Rationale
The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages.

## Backwards Compatibility
All ARCs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The ARC must explain how the author proposes to deal with these incompatibilities. ARC submissions without a sufficient backwards compatibility treatise may be rejected outright.

## Reference Implementation

### Get Providers Example

```typescript
// dapp - main.ts
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');

channel.onmessage = (message) => {
  switch (message.data?.reference) {
    case 'arc0013:get_providers:response':
      // handle response from provider
      console.log(message.data.params.name); // "Awesome Wallet"
      break;
    default:
      break;
  }
};

channel.postMessage({
  id: '5d5186fc-2091-4e88-8ef9-05a5d4da24ed',
  reference: 'arc0013:get_providers:request',
});
```
```typescript
// provider - content-script.ts
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');

channel.onmessage = (message) => {
  switch (message.data?.reference) {
    case 'arc0013:get_providers:request':
      channel.postMessage({
        id: '6695f990-e3d7-41c4-bb26-64ab8da0653b',
        params: {
          host: 'https://awesome-wallet.com',
          icon: 'data:image/png;base64,iVBORw0KGgoAAAANSUh...',
          name: 'Awesome Wallet',
          networks: [
            {
              genesisHash: 'wGHE2Pwdvd7S12BL5FaOP20EGYesN73ktiC1qzkkit8=',
              genesisId: 'mainnet-v1.0',
              methods: ['enable', 'postTxns', 'signAndPostTxns', 'signBytes', 'signTxns'],
            },
            {
              genesisHash: 'SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI=',
              genesisId: 'testnet-v1.0',
              methods: ['enable', 'postTxns', 'signAndPostTxns', 'signBytes', 'signTxns'],
            },
          ],
          providerId: '85533948-4d0b-4727-904e-dd35305d49aa',
        },
        reference: 'arc0013:get_providers:response',
        requestId: message.data?.id, // use the request id
      });
      break;
    default:
      break;
  }
};
```

### Enable Example

```typescript
// dapp - main.ts
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');

channel.onmessage = (message) => {
  switch (message.data?.reference) {
    case 'arc0013:enable:response':
      // handle response from provider
      console.log(message.data?.params.accounts[0].address); // "ARCI3GVTJO27GGSWHZR2S3E7UY46KXFLBC6CLEMF7GY3UYF7YWGWC6NPTA"
      break;
    default:
      break;
  }
};

channel.postMessage({
  id: '7fdbea43-5b7d-40af-ae6c-feff84e775fb',
  params: {
    genesisHash: 'SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI=',
    providerId: '85533948-4d0b-4727-904e-dd35305d49aa',
  },
  reference: 'arc0013:enable:request',
});
```
```typescript
// provider - content-script.ts
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');

channel.onmessage = (message) => {
  switch (message.data?.reference) {
    case 'arc0013:enable:request':
      channel.postMessage({
        id: '6695f990-e3d7-41c4-bb26-64ab8da0653b',
        params: {
          accounts: [{
            address: 'ARCI3GVTJO27GGSWHZR2S3E7UY46KXFLBC6CLEMF7GY3UYF7YWGWC6NPTA',
            name: 'Main Account',
          }],
          genesisHash: 'SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI=',
          genesisId: 'testnet-v1.0',
          providerId: '85533948-4d0b-4727-904e-dd35305d49aa',
          sessionId: '6eb74cf1-93e8-400c-94b5-4928807a3ab1',
        },
        reference: 'arc0013:enable:response',
        requestId: message.data?.id, // use the request id
      });
      break;
    default:
      break;
  }
};
```

### Sign Transactions Example

```typescript
// dapp - main.ts
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');

channel.onmessage = (message) => {
  switch (message.data?.reference) {
    case 'arc0013:sign_txns:response':
      // handle response from provider
      console.log(message.data?.params.stxns[0]); // "iaNhbXT..."
      console.log(message.data?.params.stxns[1]); // null
      break;
    default:
      break;
  }
};

channel.postMessage({
  id: '7fdbea43-5b7d-40af-ae6c-feff84e775fb',
  params: {
    genesisHash: 'SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI=',
    providerId: '85533948-4d0b-4727-904e-dd35305d49aa',
    txns: [
      {
        txn: 'iaNhbXT...', // transaction to be signed
      },
      {
        txn: 'iaNhbXT...', // signers is empty, will not be signed
        'signers': []
      },
    ],
  },
  reference: 'arc0013:enable:request',
});
```
```typescript
// provider - content-script.ts
const channel: BroadcastChannel = new BroadcastChannel('arc0013:channel');

channel.onmessage = (message) => {
  switch (message.data?.reference) {
    case 'arc0013:sign_txns:request':
      channel.postMessage({
        id: '6695f990-e3d7-41c4-bb26-64ab8da0653b',
        params: {
          genesisHash: 'SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI=',
          genesisId: 'testnet-v1.0',
          providerId: '85533948-4d0b-4727-904e-dd35305d49aa',
          stxns: [
            'iaNhbXT...',
            null,
          ],
        },
        reference: 'arc0013:enable:response',
        requestId: message.data?.id, // use the request id
      });
      break;
    default:
      break;
  }
};
```

### Sign Bytes Example





An optional section that contains a reference/example implementation that people can use to assist in understanding or implementing this specification.  If the implementation is too large to reasonably be included inline, then consider adding it as one or more files in `../assets/arc-####/`.





## Security Considerations
All ARCs must contain a section that discusses the security implications/considerations relevant to the proposed change. Include information that might be important for security discussions, surfaces risks and can be used throughout the life cycle of the proposal. E.g. include security-relevant design decisions, concerns, important discussions, implementation-specific guidance and pitfalls, an outline of threats and risks and how they are being addressed. ARC submissions missing the "Security Considerations" section will be rejected. An ARC cannot proceed to status "Final" without a Security Considerations discussion deemed sufficient by the reviewers.

## Copyright
Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.
